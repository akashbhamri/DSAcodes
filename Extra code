#!/bin/bash

# Accept parameters from Jenkins
SERVER_IPS="$1"  # List of server IPs from Jenkins string parameter
USERNAME="$2"    # Username from Jenkins

# Output CSV file
OUTPUT_FILE="server_data.csv"

# Mapping of IP addresses to tool names
declare -A IP_TO_TOOL
IP_TO_TOOL=(
    ["192.168.1.10"]="Jenkins"
    ["192.168.1.11"]="Udeploy"
    ["192.168.1.12"]="Tool3"
    # Add more mappings as needed
)

# Function to fetch server data
fetch_data() {
    local TOOL_NAME=$1
    local SERVER_IP=$2
    
    echo "Fetching data for tool $TOOL_NAME from $SERVER_IP..."

    # Using SSH key-based authentication to execute commands on the remote server
    SERVER_INFO=$(ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no "$USERNAME@$SERVER_IP" bash -s << 'ENDSSH'
        HOSTNAME=$(hostname)

        # Determine environment
        if [[ "$HOSTNAME" == vp* ]]; then
            if [[ "$HOSTNAME" == *apda[0-9]* ]]; then
                ENVIRONMENT="Production"
            elif [[ "$HOSTNAME" == *apph[0-9]* ]]; then
                ENVIRONMENT="Disaster Recovery"
            else
                ENVIRONMENT="Unknown"
            fi
        elif [[ "$HOSTNAME" == vd* ]]; then
            ENVIRONMENT="Development"
        else
            ENVIRONMENT="Unknown"
        fi

        # Get OS name and version using lsb_release
        OS_NAME=$(/usr/bin/lsb_release -i | /bin/awk -F':' '{print $2}' | xargs)
        OS_VERSION=$(/usr/bin/lsb_release -r | /bin/awk -F':' '{print $2}' | xargs)
        CPU_CORES=$(/usr/bin/nproc)
        MEMORY_TOTAL=$(/usr/bin/free -h | /bin/awk '/^Mem:/{print $2}')
        MEMORY_USED=$(/usr/bin/free -h | /bin/awk '/^Mem:/{print $3}')
        MEMORY_FREE=$(/usr/bin/free -h | /bin/awk '/^Mem:/{print $4}')
        SWAP_TOTAL=$(/usr/bin/free -h | /bin/awk '/^Swap:/{print $2}')
        SWAP_USED=$(/usr/bin/free -h | /bin/awk '/^Swap:/{print $3}')
        SWAP_FREE=$(/usr/bin/free -h | /bin/awk '/^Swap:/{print $4}')

        # Function to get disk usage
        get_disk_usage() {
            local PATH=$1
            if /bin/df -h "$PATH" &>/dev/null; then
                /bin/df -h "$PATH" | /bin/awk 'NR==2 {print $2 "," $3 "," $4}'
            else
                echo "Not Available,Not Available,Not Available"
            fi
        }

        # Function to get mount point
        get_mount_point() {
            local PATH=$1
            /bin/df -h "$PATH" | /bin/awk 'NR==2 {print $1}'
        }

        APPDATA_MOUNT=$(get_mount_point /appdata)
        APPBIN_MOUNT=$(get_mount_point /appbin)

        APPDATA=$(get_disk_usage /appdata)
        APPBIN=$(get_disk_usage /appbin)
        TMP=$(get_disk_usage /tmp)
        ROOT=$(get_disk_usage /)

        echo "$ENVIRONMENT,$HOSTNAME,$OS_NAME,$OS_VERSION,$CPU_CORES,$MEMORY_TOTAL,$MEMORY_USED,$MEMORY_FREE,$SWAP_TOTAL,$SWAP_USED,$SWAP_FREE,$APPDATA_MOUNT,$APPDATA,$APPBIN_MOUNT,$APPBIN,$TMP,$ROOT"
ENDSSH
)

    # Append data to CSV file
    echo "$TOOL_NAME,$SERVER_IP,$SERVER_INFO" >> "$OUTPUT_FILE"
}

# Initialize CSV file with headers
echo "Tool Name,Environment,Server IP,Hostname,OS Name,OS Version,CPU Cores,Memory Total,Memory Used,Memory Free,Swap Total,Swap Used,Swap Free,AppData Mount,AppData Total,AppData Used,AppData Free,AppBin Mount,AppBin Total,AppBin Used,AppBin Free,Tmp Total,Tmp Used,Tmp Free,Root Total,Root Used,Root Free" > "$OUTPUT_FILE"

# Process each server IP
IFS=',' read -ra ADDR <<< "$SERVER_IPS"
for SERVER_IP in "${ADDR[@]}"; do
    TOOL_NAME=${IP_TO_TOOL[$SERVER_IP]}
    fetch_data "$TOOL_NAME" "$SERVER_IP"
done

echo "Data collection complete. Output saved to $OUTPUT_FILE."
